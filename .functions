# Simple calculator
function calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//';  # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar using \`${cmd}\`…";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";
    echo "${tmpFile}.gz created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* *;
    fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;

# Create a git.io short URL
function gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1");
    local gzipsize=$(gzip -c "$1" | wc -c);
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
    printf "orig: %d bytes\n" "$origsize";
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
    if [ -t 0 ]; then # argument
        python -mjson.tool <<< "$*" | pygmentize -l javascript;
    else # pipe
        python -mjson.tool | pygmentize -l javascript;
    fi;
}

# UTF-8-encode a string of Unicode symbols
function escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

function get_version_ctl_branch() {
	local dir="$PWD"
	local vcs
	local nick
	while [[ "$dir" != "/"  ]]; do
		for vcs in git hg svn bzr; do
			if [[ -d "$dir/.$vcs"  ]] && hash "$vcs" &>/dev/null; then
				case "$vcs" in
					git) __git_ps1 "${1:-(%s) }"; return;; 
					hg) nick=$(hg branch 2>dev/null);;
					svn) nick=$(svn info 2>/dev/null\
						| grep -e '^Repository Root:'\
						| sed -e 's#.*/##');;
					bzr)
						local conf="${dir}/.bzr/branch/branch.conf"
						[[ -f "$conf"  ]] && nick=$(grep -E '^nickname =' "$conf" | cut -d' ' -f 3)
						conf="${dir}/.bzr/branch/location" # colo/lightweight branch
							[[ -z "$nick"  ]] && [[ -f "$conf"  ]] && nick="$(basename "$(< $conf)")"
							[[ -z "$nick"  ]] && nick="$(basename "$(readlink -f "$dir")")";;
				esac
				[[ -n "$nick"  ]] && printf "${1:-(%s) }" "$nick"
				return 0
			fi
		done
		dir="$(dirname "$dir")"
	done
}

get_styled_version_ctl_branch() {
	CUR_BRANCH=$(get_version_ctl_branch "$1")
	if [[ "${CUR_BRANCH}" =~ ^.*(master).*$  ]]; then
		printf "\033[38;5;257m${CUR_BRANCH}\033[00m"
	else
			printf "\033[38;5;173m${CUR_BRANCH}\033[00m"
	fi
}

printAnsiiTable() {
    # generates an 8 bit color table (256 colors) for reference,
	# using the ANSI CSI+SGR \033[48;5;${val}m for background and
	# \033[38;5;${val}m for text (see "ANSI Code" on Wikipedia)
	#
	echo -en "\n   +  "
	for i in {0..35}; do
		printf "%2b " $i
	done
	printf "\n\n %3b  " 0
	for i in {0..15}; do
		echo -en "\033[48;5;${i}m \033[m "
	done

	#for i in 16 52 88 124 160 196 232; do
	for i in {0..6}; do
		let "i = i*36 +16"
		printf "\n\n %3b " $i
		for j in {0..35}; do
			let "val = i+j"
			echo -en "\033[48;5;${val}m  \033[m "
		done
	done 
                                                                                                                                echo -e "\n"
}
function npm-do {
    (PATH=$(npm bin):$PATH; eval $@;)
}

mochaDebug() {
    ./node_modules/.bin/mocha --debug-brk --compilers js:babel-register $1
}
