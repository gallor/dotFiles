# Switch Profile in iTmrm 2
function it2prof() {
  echo -e "\033]50;SetProfile=$1\a";
}
# Simple calculator
function calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//';  # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar using \`${cmd}\`…";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";
    echo "${tmpFile}.gz created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* *;
    fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;

# Create a git.io short URL
function gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1");
    local gzipsize=$(gzip -c "$1" | wc -c);
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
    printf "orig: %d bytes\n" "$origsize";
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
    if [ -t 0 ]; then # argument
        python -mjson.tool <<< "$*" | pygmentize -l javascript;
    else # pipe
        python -mjson.tool | pygmentize -l javascript;
    fi;
}

# UTF-8-encode a string of Unicode symbols
function escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

function get_version_ctl_branch() {
	local dir="$PWD"
	local vcs
	local nick
	while [[ "$dir" != "/"  ]]; do
		for vcs in git hg svn bzr; do
			if [[ -d "$dir/.$vcs"  ]] && hash "$vcs" &>/dev/null; then
				case "$vcs" in
					git) __git_ps1 "${1:-(%s) }"; return;; 
					hg) nick=$(hg branch 2>dev/null);;
					svn) nick=$(svn info 2>/dev/null\
						| grep -e '^Repository Root:'\
						| sed -e 's#.*/##');;
					bzr)
						local conf="${dir}/.bzr/branch/branch.conf"
						[[ -f "$conf"  ]] && nick=$(grep -E '^nickname =' "$conf" | cut -d' ' -f 3)
						conf="${dir}/.bzr/branch/location" # colo/lightweight branch
							[[ -z "$nick"  ]] && [[ -f "$conf"  ]] && nick="$(basename "$(< $conf)")"
							[[ -z "$nick"  ]] && nick="$(basename "$(readlink -f "$dir")")";;
				esac
				[[ -n "$nick"  ]] && printf "${1:-(%s) }" "$nick"
				return 0
			fi
		done
		dir="$(dirname "$dir")"
	done
}

function get_styled_version_ctl_branch() {
	CUR_BRANCH=$(get_version_ctl_branch "$1")
	if [[ "${CUR_BRANCH}" =~ ^.*(master).*$  ]]; then
		printf "\033[38;5;257m${CUR_BRANCH}\033[00m"
	else
			printf "\033[38;5;173m${CUR_BRANCH}\033[00m"
	fi
}

function ansiiTable() {
    # generates an 8 bit color table (256 colors) for reference,
	# using the ANSI CSI+SGR \033[48;5;${val}m for background and
	# \033[38;5;${val}m for text (see "ANSI Code" on Wikipedia)
	#
	echo -en "\n   +  "
	for i in {0..35}; do
		printf "%2b " $i
	done
	printf "\n\n %3b  " 0
	for i in {0..15}; do
		echo -en "\033[48;5;${i}m \033[m "
	done

	#for i in 16 52 88 124 160 196 232; do
	for i in {0..6}; do
		let "i = i*36 +16"
		printf "\n\n %3b " $i
		for j in {0..35}; do
			let "val = i+j"
			echo -en "\033[48;5;${val}m  \033[m "
		done
	done 
    echo -e "\n"
}

function npm-do {
    (PATH=$(npm bin):$PATH; eval $@;)
}

function mochaDebug() {
    ./node_modules/.bin/mocha --debug-brk --compilers js:babel-register $1
}

# ========================
# fzf functions
# ========================
# using ripgrep combined with preview
# find-in-file - usage: fif <searchTerm>
fif() {
  if [ ! "$#" -gt 0 ]; then echo "Need a string to search for!"; return 1; fi
  rg --files-with-matches --hidden --no-messages "$1" | fzf --preview "highlight -O ansi -l {} 2> /dev/null | rg --colors 'match:bg:yellow' --ignore-case --pretty --hidden --context 10 '$1' || rg --ignore-case --hidden --pretty --context 10 '$1' {}"
}

# cd to selected directory
fd() {
  local dir
  dir=$(find ${1:-.} -path '*/\.*' -prune \
                  -o -type d -print 2> /dev/null | fzf +m) &&
  cd "$dir"
}

# cd into selected directory including hidden
fda() {
  local dir
  dir=$(find ${1:-.} -type d 2> /dev/null | fzf +m) && cd "$dir"
}

# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# vf - fuzzy open with vim from anywhere
# ex: vf word1 word2 ... (even part of a file name)
# zsh autoload function
vf() {
  local files

  files=(${(f)"$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0 -0 -1 -m)"})

  if [[ -n $files ]]
  then
     nvim -- $files
     print -l $files[1]
  fi
}

# fuzzy grep open via ag
vg() {
  local file

  file="$(ag --nobreak --noheading $@ | fzf -0 -1 | awk -F: '{print $1}')"

  if [[ -n $file ]]
  then
     nvim $file
  fi
}

# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
fstash() {
  local out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    mapfile -t out <<< "$out"
    q="${out[0]}"
    k="${out[1]}"
    sha="${out[-1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}

gru() {
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  read -p "Main branch: [${CURRENT_BRANCH}] " MAIN_BRANCH
  if [ -z "$MAIN_BRANCH" ]; then
     MAIN_BRANCH=${CURRENT_BRANCH}
  fi
  echo $MAIN_BRANCH 
  git fetch upstream $MAIN_BRANCH
  git pull --rebase upstream $CURRENT_BRANCH
  git push --force
  git fetch upstream
}

# Git checkout new branch
gco() {
  local branch=$(git branch | fzf)

  if [[ $branch ]]; then
    git checkout $branch; git pull;
  fi
}

grm() {
  local branch=$(git branch | fzf)

  if [[ $branch ]]; then
    git branch -D $branch  
  fi
}

gcoa() {
  git fetch --all;
  local branch=$(git branch --all | fzf)

  if [[ $branch ]]; then
    local newBranch=$(echo $branch | sed "s/remotes\/origin\///");
    git checkout -b $newBranch $branch;
  fi
}

# tm - create new tmux session, or switch to existing one. Works from within tmux too. (@bag-man)
# `tm` will allow you to select your tmux session via fzf.
# `tm irc` will attach to the irc session (if it exists), else it will create it.
tm() {
  [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
  if [ $1 ]; then
    tmux $change -t "$1" 2>/dev/null || (tmux new-session -d -s $1 && tmux $change -t "$1"); return
  fi
  session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0) &&  tmux $change -t "$session" || echo "No sessions found."
}

# Get a list of conda environments to pick one to activate
cm() {
  local env=$(conda env list | sed '1,2d' | awk '{print $1}' | fzf)

  if [[ $env ]]; then
    conda deactivate
    conda activate $env
  fi
}

# Install (one or multiple) selected application(s)
# using "brew search" as source input
# mnemonic [B]rew [I]nstall [P]lugin
bip() {
  local inst=$(brew search | fzf -m)

  if [[ $inst ]]; then
    for prog in $(echo $inst)
    do
      brew install $prog
    done
  fi
}

# Update (one or multiple) selected application(s)
# mnemonic [B]rew [U]pdate [P]lugin
bup() {
  local upd=$(brew leaves | fzf -m)

  if [[ $upd ]]; then
    for prog in $(echo $upd)
    do
      brew upgrade $prog
    done
  fi
}

# Delete (one or multiple) selected application(s)
# mnemonic [B]rew [D]elete [P]lugin (e.g. uninstall)
bdp() {
  local uninst=$(brew leaves | fzf -m)

  if [[ $uninst ]]; then
    for prog in $(echo $uninst)
    do
      brew uninstall $prog
    done
  fi
}

# Install or open the webpage for the selected application 
# using brew cask search as input source
# and display a info quickview window for the currently marked application
install() {
    local token
    token=$(brew search --casks | fzf-tmux --query="$1" +m --preview 'brew info {}')

    if [ "x$token" != "x" ]
    then
        echo "(I)nstall or open the (h)omepage of $token"
        read input
        if [ $input = "i" ] || [ $input = "I" ]; then
            brew install --cask $token
        fi
        if [ $input = "h" ] || [ $input = "H" ]; then
            brew home $token
        fi
    fi
}

# Uninstall or open the webpage for the selected application 
# using brew list as input source (all brew cask installed applications) 
# and display a info quickview window for the currently marked application
uninstall() {
    local token
    token=$(brew list --casks | fzf-tmux --query="$1" +m --preview 'brew info {}')

    if [ "x$token" != "x" ]
    then
        echo "(U)ninstall or open the (h)omepage of $token"
        read input
        if [ $input = "u" ] || [ $input = "U" ]; then
            brew uninstall $token
        fi
        if [ $input = "h" ] || [ $token = "h" ]; then
            brew home $token
        fi
    fi
}

# Select a docker container to start and attach to
function da() {
  local cid
  cid=$(docker ps -a | sed 1d | fzf -1 -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker start "$cid" && docker attach "$cid"
}

# Select a running docker container to stop
function ds() {
  local cid
  cid=$(docker ps | sed 1d | fzf -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker stop "$cid"
}

# Select a docker container to remove
function drm() {
  local cid
  cid=$(docker ps -a | sed 1d | fzf -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker rm "$cid"
}
